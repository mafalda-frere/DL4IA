import os
import torch
from torch.utils.data import Dataset

import numpy as np


class mriData(Dataset):
    """Dataset of MRI data in k-space.
    """
    def __init__(self, data_folder):
        super(mriData, self).__init__()
        self.data_folder = data_folder
        self.files = os.listdir(data_folder)
        self.files.sort()

    def __len__(self):
        return len(self.files)
    
    def __getitem__(self, i):
        file = self.files[i]
        file_name = os.path.join(self.data_folder, file)
        kspace = np.load(file_name) # numpy array 
        kspace = torch.from_numpy(kspace) # converti en tenseur 
        return kspace


class fastMriData(mriData):
    """Dataset that simulates the acceleration of the 
    MRI data acquisition process, given an undersampling scheme.
    Gives pairs for training a ML model to reconstruct MRI from
    undersampled measurements.
    """
    def __init__(self, data_folder: str, mask: torch.Tensor, mean: float, std: float):
        super(fastMriData, self).__init__(data_folder)
        self.mask = mask
        
        if mean is None or std is None:
            self.mean, self.std = self.dataset_statistics()
        else:
            self.mean = mean
            self.std = std

    def dataset_statistics(self):
        """Computes mean and std over every images in dataset.
        """
        images = []
        for i in range(len(self)):
            target_kspace = super().__getitem__(i)
            _, obs_image = self.measurement(target_kspace, self.mask)
            images.append(obs_image)
        
        images = torch.cat(images)
        mean = torch.mean(images)
        std = torch.std(images)
        return mean, std
    
    @staticmethod
    def measurement(target_kspace: torch.Tensor, mask: torch.Tensor):   # sous-échantillonne données dans l'espace de fourier
        """Simulates a measurement.
        """
        obs_kspace = np.zeros_like(target_kspace)
        obs_kspace[:, mask]=target_kspace[:, mask]
        obs_image = np.abs(
            np.fft.ifft2(obs_kspace)
            )
        return obs_kspace,obs_image

    def __getitem__(self, i):
        target_kspace = super().get__item__(i) # revient à ce qu'on a fait dans le notebook (super : désigne la classe parente, cad mridata)
        target_image = torch.abs(torch.fft.ifftn(target_kspace))

        obs_kspace, obs_image = self.measurement(target_kspace,self.mask)

        obs_image = (obs_image.float() - self.mean) / self.std  # on centre et on réduit (courant en entrée de RdN)
        target_image = (target_image.float() - self.mean) / self.std

        obs_kspace = torch.fft.fftshift(torch.fft.fftn(obs_image))
        target_kspace = torch.fft.fftshift(torch.fft.fftn(target_image))

        return obs_image, obs_kspace, target_image, target_kspace  # renvoie données mesurées et les données cible qu'on eut reconstruire dans l'espace image et celle de fourier


    def kspace_mask(kspace_shape, acceleration_factor: int = 4):
        """Implementation of Cartesian Undersampling, as described in:
        Knoll et al. (2020). fastMRI: A Publicly Available Raw k-Space and DICOM Dataset 
        of Knee Images for Accelerated MR Image Reconstruction Using Machine Learning. 
        Radiology: Artificial Intelligence. doi: 10.1148/ryai.2020190007.

        "All undersampling masks are generated by first including some number of adjacent lowest-
        frequency k-space lines to provide a fully-sampled k-space region. When the acceleration factor
        equals four, the fully-sampled central region includes 8% of all k-space lines; when it equals eight,
        4% of all k-space lines are included." Remaining k-space lines are, here, included uniformly at random.
        """
        n_columns = kspace_shape[-1]
        center = n_columns // 2
        n_tot = n_columns // acceleration_factor
        
        if acceleration_factor == 4:
            n_center = int(n_columns * 0.08)
        elif acceleration_factor == 8:
                n_center = int(n_columns * 0.04)
        else: 
            raise NotImplementedError("Acceleration factor must be 4 or 8")
        random_mask = np.zeros(n_columns)
        random_mask[center - n_center // 2 : center + n_center //2 -1] = 1

        n_high_freq = n_tot - n_center
        high_freq = np.concatenate((
            np.arange(center - n_center // 2),
            np.arange(center + n_center // 2 - 1, n_columns)
        ))
        
        high_freq = np.random.choice(high_freq, size=n_high_freq, replace=False)
        random_mask[high_freq] = 1
        random_mask = torch.from_numpy(random_mask == 1)

        return random_mask